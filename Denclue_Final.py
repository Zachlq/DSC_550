{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sknetwork.topology import connected_components\n",
    "from sknetwork.utils import edgelist2adjacency\n",
    "from sklearn.datasets import load_iris\n",
    "import numpy as np\n",
    "import multiprocessing as mp\n",
    "from numpy import genfromtxt\n",
    "\n",
    "h = 0.7 \n",
    "\n",
    "D = genfromtxt('iris.txt', delimiter=',')\n",
    "(n, d) = np.shape(D)\n",
    "\n",
    "d = 4\n",
    "X = D[:,0:d]\n",
    "epsilon = 0.0001\n",
    "squiggly_e = 0.05\n",
    "\n",
    "def dmvnorm_std(x):# []\n",
    "    \"\"\"\n",
    "    Taken from: https://github.com/zakimjz/dmbook-slides/blob/master/CLUST/density/figs/denclue.py\n",
    "    :param x:\n",
    "    :return: returns the vector normal\n",
    "    \"\"\"\n",
    "    part1 = np.power(2*np.pi, d/2)\n",
    "    prod = np.dot(x, x)\n",
    "    part2 = np.exp(-0.5*prod)\n",
    "    res =  part2/part1\n",
    "    return res\n",
    "\n",
    "# update denclue1.0 rule (gradient based)\n",
    "def gradient_update_x(x):\n",
    "    \"\"\"\n",
    "    Taken from: https://github.com/zakimjz/dmbook-slides/blob/master/CLUST/density/figs/denclue.py\n",
    "    :param x:\n",
    "    :return:\n",
    "    \"\"\"\n",
    "    step = 0.05\n",
    "    Z = (x - X) / h\n",
    "    Kvals = map(dmvnorm_std, Z)\n",
    "    Kvals = [val * h * -1.0 for val in Kvals]\n",
    "    grad = np.sum(Kvals * Z.T, axis=1)\n",
    "    grad = grad / (n * h ** (d + 2))\n",
    "    xnew = x + step * grad\n",
    "    return xnew\n",
    "\n",
    "def find_attractor(idx):\n",
    "    \"\"\"\n",
    "    Taken from: https://github.com/zakimjz/dmbook-slides/blob/master/CLUST/density/figs/denclue.py\n",
    "    :param idx:\n",
    "    :return:\n",
    "    \"\"\"\n",
    "    done = True\n",
    "    t = 0\n",
    "    x = X[idx, :]\n",
    "    while (done):\n",
    "\n",
    "        xnew = gradient_update_x(x)\n",
    "\n",
    "        diff = np.linalg.norm(xnew - x)\n",
    "        done = diff > epsilon\n",
    "        t = t + 1\n",
    "        x = xnew\n",
    "    print(idx, t, x)\n",
    "    return x\n",
    "\n",
    "def get_point_as_array(str):\n",
    "    \"\"\"\n",
    "    Given a string \"'6.13 2.86 4.71 1.58'\" return it as an numpy array of separate float values\n",
    "    :param str:\n",
    "    :return:\n",
    "    \"\"\"\n",
    "    return np.array([float(x) for x in str.split()])\n",
    "\n",
    "def filter_out_based_on_squiggle_e(list_of_points, squiggle_e):\n",
    "    \"\"\"\n",
    "    Lines 5, 7, 9 from DENCLUE Algorithm from Text\n",
    "    :param list_of_points:\n",
    "    :param squiggle_e:\n",
    "    :return:\n",
    "    \"\"\"\n",
    "    res = []\n",
    "    list_of_attractors = {}\n",
    "    for i in range(len(list_of_points)):\n",
    "        for j in range(len(list_of_points)):\n",
    "            if j < i:\n",
    "                continue\n",
    "            list_i = get_point_as_array(list_of_points[i])\n",
    "            list_j = get_point_as_array(list_of_points[j])\n",
    "            if np.linalg.norm(list_i - list_j) <= squiggle_e:\n",
    "                # save for printing later\n",
    "                if list_of_points[i] in list_of_attractors:\n",
    "                    list_of_attractors[list_of_points[i]].append(list_of_points[j])\n",
    "                else:\n",
    "                    list_of_attractors[list_of_points[i]] = [list_of_points[j]]\n",
    "                res.append((i, j))\n",
    "\n",
    "    return res, list_of_attractors\n",
    "\n",
    "def connected_graph(edgelist):\n",
    "    \"\"\"\n",
    "    Use sknetwork to generate a connected graph of all the unique attractor points. Use the\n",
    "    \"connected_components\" method below to then tell us what values are \"density reachable\"\n",
    "    https://scikit-network.readthedocs.io/en/stable/tutorials/getting_started.html\n",
    "    :param list_of_points:\n",
    "    :return:\n",
    "    \"\"\"\n",
    "    # take raw list of edges and generate a CSR graph\n",
    "    adjacency = edgelist2adjacency(edgelist)\n",
    "\n",
    "    # get the list of density reachable clusters\n",
    "    clusters = connected_components(adjacency)\n",
    "    #print(clusters)\n",
    "\n",
    "    #for label in clusters:\n",
    "    #    print(label)\n",
    "    return clusters\n",
    "\n",
    "######### BEGIN TAKEN FROM #########\n",
    "# Taken From: https://github.com/zakimjz/dmbook-slides/blob/master/CLUST/density/figs/denclue.py\n",
    "#########\n",
    "par = mp.Pool(1)\n",
    "attractors = par.map(find_attractor, range(n))\n",
    "\n",
    "#find unique attractors, assign points to clusters\n",
    "#use two digits after decimal for proximity\n",
    "clusters = {}\n",
    "for i in range(n):\n",
    "    hashL = [\"%0.2f\"%x for x in attractors[i]]\n",
    "    hashval = \" \".join(hashL)\n",
    "    if hashval not in clusters: clusters[hashval] = []\n",
    "    clusters[hashval].append(i)\n",
    "\n",
    "Uattrs = [hval for hval in clusters]\n",
    "#### END TAKEN FROM dmbook-slides ######\n",
    "\n",
    "list_of_edges, list_of_attractors = filter_out_based_on_squiggle_e(Uattrs, squiggly_e)\n",
    "all_labels = connected_graph(list_of_edges)\n",
    "\n",
    "# print the points and their attractors\n",
    "#print(\"{} Attactors: {}:\".format(len(Uattrs), Uattrs))\n",
    "for attractor, list_of_points in list_of_attractors.items():\n",
    "    print(\"attractor = {} list_of_points [{}]\".format(attractor, \",\".join(list_of_points)))\n",
    "\n",
    "# print the number of clusters\n",
    "unique_clusters = set()\n",
    "for x in all_labels:\n",
    "    unique_clusters.add(x)\n",
    "print(\"total clusters: {}\".format(len(unique_clusters)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
